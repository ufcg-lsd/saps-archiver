package saps.archiver.core;

import saps.archiver.interfaces.*;
import java.util.Properties;
import java.io.IOException;
import java.util.List;
import java.util.ArrayList;
import java.io.File;
import org.apache.commons.io.FileUtils;
import org.apache.log4j.Logger;
import saps.catalog.core.Catalog;
import saps.catalog.core.retry.CatalogUtils;
import saps.common.core.model.SapsImage;
import saps.common.core.model.enums.ImageTaskState;
import saps.common.utils.SapsPropertiesConstants;
import saps.common.utils.SapsPropertiesUtil;


public class DefaultArchiver implements Archiver {
  private final Catalog catalog;
  private final PermanentStorage permanentStorage;

  private final String tempStoragePath;

  private static final Logger LOGGER = Logger.getLogger(Archiver.class);

  public DefaultArchiver(
    Properties properties,
    Catalog catalog,
    PermanentStorage permanentStorage) throws IllegalArgumentException {

    if (!checkProperties(properties)) {
    	throw new IllegalArgumentException("Error on validate the file. Missing properties for start Saps Controller.");
    }
 
    this.catalog = catalog;
    this.permanentStorage = permanentStorage;
    this.tempStoragePath = properties.getProperty(SapsPropertiesConstants.SAPS_TEMP_STORAGE_PATH);
  }

  public List<SapsImage> archive() {
	  
    List <SapsImage> tasksToArchive = CatalogUtils.getTasks(catalog, ImageTaskState.FINISHED);
    List<SapsImage> archivedTasks = new ArrayList<>();

    for (SapsImage task: tasksToArchive) {
      updateTaskState(task, ImageTaskState.ARCHIVING);
      if (archive(task)) {
        updateTaskState(task, ImageTaskState.ARCHIVED); 
        archivedTasks.add(task);
      } else {
        updateTaskState(task, ImageTaskState.FAILED);
      } 
      deleteTempData(task);
    }
    return tasksToArchive;
  }

  private boolean archive(SapsImage task) {

    try {
      permanentStorage.archive(task);
      return true;
    } catch (IOException e) {
      LOGGER.error("Error archiving task [" + task.getTaskId() + "]", e);
      return false;
    }
  }

  public List<SapsImage> gc() {

    List<SapsImage> failedTasks = CatalogUtils.getTasks(catalog, ImageTaskState.FAILED);
    failedTasks.forEach(this::deleteTempData);
    
    return failedTasks;
  };

  private boolean checkProperties(Properties properties) {

    String[] propertiesSet = {
      SapsPropertiesConstants.SAPS_EXECUTION_PERIOD_GARBAGE_COLLECTOR,
      SapsPropertiesConstants.SAPS_EXECUTION_PERIOD_ARCHIVER,
      SapsPropertiesConstants.SAPS_TEMP_STORAGE_PATH
  };

  return SapsPropertiesUtil.checkProperties(properties, propertiesSet);
  }

  /**
   * It updates {@code SapsImage} state in {@code Catalog}.
   *
   * @param task task to be updated
   * @param state new task state
   * @param status new task status
   * @param error new error message
   * @param arrebolJobId new Arrebol job id
   * @return boolean representation reporting success (true) or failure (false) in update {@code
   *     SapsImage} state in {@code Catalog}
   */
  private void updateTaskState(SapsImage task, ImageTaskState state) {

    task.setState(state);
    task.setStatus(SapsImage.NON_EXISTENT_DATA);
    task.setError(SapsImage.AVAILABLE);
    task.setArrebolJobId(SapsImage.NONE_ARREBOL_JOB_ID);

    CatalogUtils.addTimestampTask(catalog, task);

    CatalogUtils.updateState(catalog, task);
  }

  /**
   * It deletes the data generated by {@code SapsImage} in the temp storage.
   *
   * @param task {@code SapsImage}
   */
  private void deleteTempData(SapsImage task) {    

    String taskDirPath = tempStoragePath + File.separator + task.getTaskId();
    
    File taskDir = new File(taskDirPath);
      LOGGER.info("Deleting temp data from task [" + task.getTaskId() + "]");
      FileUtils.deleteQuietly(taskDir);
  }
}
